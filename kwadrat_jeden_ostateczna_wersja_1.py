# -*- coding: utf-8 -*-
"""kwadrat_jeden_ostateczna_wersja-1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1m96lMEHwMSJMWatSwWc0WY06Z2BHmd-F
"""

import matplotlib.pyplot as plt
import numpy as np
import math

x0 =0 #float(input('podaj x srodka okregu: ))
y0 = 0 #float(input('podaj y srodka okregu: '))
R = 4 #float(input('podaj promien okregu duzego: '))
A =3 #float(input('podaj promien okregu malego: '))
l= 2 #float(input('podaj dlugosc odcinka l: '))
n= 16 #int(input('podaj liczbę rzuconych odcinków: '))

dokladnosc = 0.01
kat = np.arange(0, 2*np.pi, dokladnosc)

x = x0 + R * np.cos(kat)
y = y0 + R * np.sin(kat)
x1 = [x0 -A/2, x0+A/2,x0+A/2,x0-A/2, x0-A/2]
y1 = [y0+A/2,y0+A/2,y0-A/2,y0-A/2,y0+A/2]
xl=x0+(R-l/2)* np.cos(kat)
yl=y0+(R-l/2)* np.sin(kat)

srodki_xs =[]
srodki_ys=[]

def odleglosc(xs,ys):
  if math.sqrt((xs-x0)**2+(ys-y0)**2) < (R-l/2):
    return xs,ys
  else:
      xs = round(np.random.uniform(x0-R,x0+R),2)
      ys= round(np.random.uniform(y0-R,y0+R),2)
      return odleglosc(xs,ys)
  return xs,ys

for i in range(0,n):
  xs = round(np.random.uniform(x0-R,x0+R),2)
  ys = round(np.random.uniform(y0-R,y0+R),2)
  srodki_xs.append(xs)
  srodki_ys.append(ys)

for i in range (0,n):
  srodki_xs[i], srodki_ys[i] = odleglosc(srodki_xs[i],srodki_ys[i])
R-l/2

#TWORZYMY y=ax+b
#losujemy kąt alfa
alfy=[]
for i in range(0,n):
  alfy.append(np.random.uniform(0,180))

#współczynnik kierunkowy prostej to a
a_list=[]
for i in range (0,n):
  a_list.append(round(math.tan(alfy[i]),2))

#szukamy współczynnika b
b_list=[]
for i in range (0,n):
  b_list.append(round(srodki_ys[i]-a_list[i]*srodki_xs[i],2))

import sympy

#szukamy końców odcinka A(xi1,yi1) i B(xi2,yi2)
from sympy import symbols, Eq, solve
xi1_list=[]
xi2_list=[]
yi1_list=[]
yi2_list=[]
for i in range (0,n):
  xi=symbols('xi')
  row=Eq((sympy.sqrt((srodki_xs[i]-xi)**2+(srodki_ys[i]-(a_list[i]*xi+b_list[i]))**2))-l/2,0)
  sol=solve(row)
  if len(sol)>0:
    xi1_list.append(sol[0])
    xi2_list.append(sol[1])
    yi1_list.append(a_list[i]*sol[0]+b_list[i])
    yi2_list.append(a_list[i]*sol[1]+b_list[i])
  else:
    xs = round(np.random.uniform(x0-R,x0+R),2)
    ys = round(np.random.uniform(y0-R,y0+R),2)
    xs_nowy, ys_nowy = odleglosc(xs,ys)
    srodki_xs[i], srodki_ys[i] = xs_nowy, ys_nowy
    xi=symbols('xi')
    row=Eq((sympy.sqrt((xs_nowy-xi)**2+(ys_nowy-(a_list[i]*xi+b_list[i]))**2))-l/2,0)
    sol=solve(row)
    xi1_list.append(sol[0])
    xi2_list.append(sol[1])
    yi1_list.append(a_list[i]*sol[0]+b_list[i])
    yi2_list.append(a_list[i]*sol[1]+b_list[i])
    continue

odcinek_x_list=[]
odcinek_y_list=[]
plt.figure(figsize=(8, 8))
for i in range (0,n):
  odcinek_x_list.append([xi1_list[i],xi2_list[i]])
  odcinek_y_list.append([yi1_list[i],yi2_list[i]])
  plt.plot(xi1_list[i],yi1_list[i],'go')
  plt.plot(xi2_list[i],yi2_list[i],'go')
  plt.plot(odcinek_x_list[i],odcinek_y_list[i],'g-')
plt.plot(x, y, 'r--')
plt.plot(x1, y1, 'm-')
plt.plot(xl,yl, 'b--')
plt.show()

#[xp należy do (x0-a/2,x0+a/2) i yp należy do (y0-a/2,y0+a/2)] i [(xk<x0-a/2 lub xk>x0+a/2) i (yk<y0-a/2 lub yk>y0+a/2)]
def licz_punkty(xp,yp,xk,yk,A,a,b):
  k=0
  if math.sqrt((xp-x0)**2)<=A/2 and math.sqrt((yp-y0)**2)<=A/2:
    if not (math.sqrt((xk-x0)**2)<A/2 and math.sqrt((yk-y0)**2)<A/2):
      k+=1
  elif math.sqrt((xk-x0)**2)<=A/2 and math.sqrt((yk-y0)**2)<=A/2:
    if not (math.sqrt((xp-x0)**2)<=A/2 and math.sqrt((yp-y0)**2)<=A/2):
      k+=1 #liczy normalne przypadki
  elif 4*a**2-4*b**2+4+8*a-8*a*b**2 >=0:
    k+=0.5

  return k

k=0
for i in range (0,n):
  k+=licz_punkty(xi1_list[i],yi1_list[i], xi2_list[i], yi2_list[i],A, a_list[i],b_list[i])
k

L=4*A
S=(math.pi)*(R**2)

(2*l*L)/(math.pi*S)

k/n



